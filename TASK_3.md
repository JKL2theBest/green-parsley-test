# Задание 3: Архитектура отправки PUSH-уведомлений

## Верхнеуровневая схема

Для реализации системы уведомлений в микросервисной архитектуре предлагается использовать **событийно-ориентированный подход (Event-Driven Architecture)** с использованием брокера сообщений.

### Диаграмма потоков данных

![Схема архитектуры Push-уведомлений](push_architecture.png)

## Описание компонентов и процесса

### 1. Сбор токенов (Device Registration)
Чтобы отправить пуш конкретному пользователю, нам нужно знать "адрес" его устройства (Device Token).
*   **Мобильное приложение** при старте запрашивает разрешение на уведомления.
*   Получает токен от провайдера (FCM/APNS).
*   Отправляет токен на бэкенд (через `POST /api/v1/devices/register`).
*   **Notification Service** сохраняет связку `UserID <-> DeviceToken` в базе данных.

### 2. Инициация уведомления (Producers)
Микросервисы не должны знать, как отправлять пуши. Они просто сообщают о том, что "что-то случилось".
*   **Cart Service:** Запускает джобу (cron), находит брошенные корзины и кидает событие `CART_ABANDONED` в брокер сообщений (Kafka).
*   **Order Service:** При смене статуса заказа кидает событие `ORDER_STATUS_CHANGED`.

### 3. Брокер сообщений (Message Broker)
Используется **Kafka** или **RabbitMQ**. Это позволяет:
*   Снизить связность (Decoupling) сервисов.
*   Гарантировать доставку (даже если сервис уведомлений временно упал, сообщения сохранятся в очереди).

### 4. Сервис уведомлений (Notification Service)
Это "мозг" рассылки. Он является Consumer-ом (читателем) очереди.
*   Читает событие.
*   Формирует текст уведомления (подставляет имя, номер заказа).
*   Ищет в БД актуальные токены пользователя.
*   Отправляет запрос во внешний шлюз (FCM для Android или APNS для iOS).

### 5. Внешние провайдеры
**FCM / APNS** — это единственные шлюзы, которые имеют постоянное соединение с мобильными устройствами и могут "разбудить" телефон для показа уведомления.
